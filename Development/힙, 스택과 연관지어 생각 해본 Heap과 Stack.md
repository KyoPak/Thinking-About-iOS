## *힙, 스택과 연관지어 생각 해본 Heap과 Stack*

---

### *클래스*

- 참조타입
- 상속 가능, 타입캐스팅 가능
- deinit을 사용하여 클래스 인스턴스의 메모리 할당을 해제 가능.
- 같은 클래스 인스턴스를 여러 개의 변수에 할당한 뒤 값을 변경시키면 할당한 모든 변수에 영향을 준다. (메모리만 복사)
- Heap에 저장되고, 그 주소값을 Stack에 저장한다.

### *구조체*

- 값타입
- 상속 불가능
- 구조체 변수를 새로운 변수에 할당할 때마다 새로운 구조체가 할당됩니다.
- Stack에 저장한다.

## *언제 클래스와 구조체를 사용하나?*

---

[https://developer.apple.com/documentation/swift/choosing-between-structures-and-classes](https://developer.apple.com/documentation/swift/choosing-between-structures-and-classes)

- 기본적으로 구조체를 사용하라고 명시
    
    하지만, 조금 실제 개발과 동떨어진 이야기이다.
    
    → UIKit은 대부분 클래스로 구현이 되어있다.
    
    → 때문에 이러한 클래스들을 상속해서 사용할 수 밖에 없다.
    
    →그래서 Model 타입 구현할때, UI요소 이외를 구현할 때 고민이 필요하다.
    

### *클래스를 사용하는 경우*

- 상속이 필요한 경우
- Objective-C와 상호운용성을 원할 경우
- ARC로 메모리관리가 필요한 경우

### *구조체를 사용하는 경우*

- 상속 받을 필요가없거나, 상속할 필요가 없는 경우.
- 단순한 데이터 값을 보유할 때는 구조체를 사용.
- 메모리의 스택은 크기가 크지 않기 때문에 작은 값을 가지는 데이터를 처리할 때 구조체를 사용한다.
- 구조체의 저장프로퍼티가 값타입이며, 참조보다는 복사가 적합할 때.

### Copy-on-assignment 란 ?

값 타입을 다른 변수에 할당하면 복사를 하게 된다. 

즉, 새로운 메모리 공간에 같은 값을 복사하게 되는데, 

이를 copy-on-assignment라고 한다.

### Copy-on-write란?

Copy-on-write는 다른 변수에 할당하면 일단은 메모리를 할당하지 않고 같은 곳을 본다. 

그러다 해당 값을 변경할 때 실제로 메모리에 값을 복사하고 값을 변경하게 된다. 

이는 메모리를 최적화해주기 위함이며 Swift에서는 Int, Double, String, Array, Set, Dictionary에서만 사용하고 있다.

## *힙영역과 스택영역의 차이점*

---

| 메모리 | Heap | Stack |
| --- | --- | --- |
| 무엇이 저장되나? | 클래스의 객체, 클로저등의 참조타입  | 구조체등의 값타입, 함수 호출시 지역변수, 매개변수, 리턴값등이 저장된다. |
| 스레드 | 스레드들이 공유하는 영역이다. 따라서, thread-safe하지 않다. | 스레드 별로 독립적인 Stack  영역을 가지고 있기 때문에 thread-safe하다. |
| 할당방식 | 동적할당 (런타임에 할당, 해제 가능). 메모리 해제에 신경써야한다. 회수영역, 사용영역을 Tracking해야한다. HeapScan과정이 필요하기 때문에 오버헤드가 발생한다.  | 정적할당 (컴파일 타임에 할당가능) - 기본적으로 메모리 해제에 대해서 신경쓰지 않는다. |
| 메모리관리 | ARC | 필요없다. |

### 메모리 할당이란?

- 프로그램에서 값을 저장하기 위해서 기억 장소를 확보하는 것

### *동적할당이란? → Heap*

- 프로그램 실행중(런타임)에 필요한만큼의 메모리를 할당, 해제하는 기법이다.
- 프로그래머가 원하는 시점에 원하는 크기만큼 메모리를 할당할 수 있다.
- 언제든지 할당한 메모리를 해제할수도 있다.
- 힙스캔 과정이 발생해서, 오버헤드가 발생하여 속도가 느릴 수 있다.

### 정적할당이란? → Stack

- 스택은 컴파일 타임에 메모리크기가 결정되기 때문에 정적할당이 적절하다고 생각한다 → 야곰
    - 할당이라는 단어의 의미에 따라 달라진다.
    - 내부 메모리가 막바뀌는게 할당의 의미면 스택은 동적이고,
    - 컴파일 타임내에 정해지는게 할당의 의미면 스택은 정적이다.
- 할당되는 크기가 정적.
- 컴파일타임에 메모리를 할당하는 것이다. 메모리의 필요량을 지정해야한다.
- 함수가 종료되면 해제된다.
- 프로그램 컴파일 시 stack에 얼만큼의 크기로 할당해야할지 결정해야하기 때문에 컴파일 이후에 크기가 변경될 수 없다.

### *오버헤드란?*

---

- 어떤 처리를 하기 위해 **간접적인 처리 시간 및 메모리** 등이 추가적으로 사용되는 현상
- '간접적'이 주요 키워드라 생각한다.
목적 달성에 본질적인 것은 아닌 부수적인 처리들,즉 필수는 아니지만 필요한 처리들에 사용되는 비용이기 때문이다.
- 예시

A라는 처리를 실행한다면 3초 걸린다.**안전성을 고려하여 B라는 처리를 추가**한 결과 처리시간이 10초가 걸렸다.
이 때 오버헤드는 7초이다.
추가로 B를 개선해 B라는 처리를 한 결과 처리시간이 5초가 되었다면 오버헤드가 5초 단축되었다고 말할 수 있다.
